
#ifndef MAP_ITERATOR_HPP
# define MAP_ITERATOR_HPP

# include <iterator>
# include "node.hpp"

namespace ft
{
	template<class Key, class T, class Compare = std::less<Key>	>
	class map_iterator
	{
		private:
			typedef ft::pair<const Key, T>	value_type;
			typedef long int				node;
			typedef size_t					size_type;

			typedef value_type&										reference;
			typedef value_typ*										pointer;
			typedef node*											nodePtr;
		private:
			nodePtr		_node;
		public:

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/********************************************************************************************************************************/
		/***********************************************************CONSTRUCTOR***********************************************************/
		/********************************************************************************************************************************/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			map_iterator(): _node(NULL) {};
			map_iterator(const map_iterator<const Key, T, Compare> &other)
			{
				*this = other;
			}
			~map_iterator(){};

			map_iterator &operator=( const map_iterator &other)
			{
				if (&other == this)
				{
					this->_node = other->_node;
					this->_lastElem = other->_lastElem;
					this->_comp = other->_isend;
				}
				return (*this); 
			}
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/********************************************************************************************************************************/
		/************************************************************GET VALUE***********************************************************/
		/********************************************************************************************************************************/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
		
			node	TreeMinimum(node root)
			{
				while (!root->leftChild->isNil())
				{
					root = root->left;
				}
				return (root);
			}

			node	TreeMaximum(node root)
			{
				while (!root->leftChild->isNil())
				{
					root = root->right;
				}
				return (root);
			}

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/********************************************************************************************************************************/
		/************************************************************OVERLOAD************************************************************/
		/********************************************************************************************************************************/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/********************************************************************************************************************************/
		/************************************************************OVERLOAD************************************************************/
		/********************************************************************************************************************************/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			map_iterator &operator=()
			{
				if (this != &other)
					_node = other._node;
				return (*this);
			}
			map_iterator &operator++()
			{
				_node = _node->next();
				return (*this);
			}
			map_iterator &operator--()
			{
				_node = _node->prev();
				return (*this);
			}
			map_iterator operator++(int)
			{
				map_iterator	tmp = *this;
				_node = _node->next();
				return (tmp);
			}
			map_iterator operator--(int)
			{
				map_iterator	tmp = *this;
				_node = _node->prev();
				return (tmp);
			}
			friend bool operator==(const map_iterator &it) const
			{
				return (it._node == _node);
			}
			friend bool &operator!=( const map_iterator &it) const
			{
				return (it._node != _node);
			}
			map_iterator &operator*(const map_iterator	&other) const
			{
				return (_node->value);
			}
			map_iterator &operator->() const
			{
				return (&_node->value);
			}
	};
}


#endif
