
#ifndef MAP_ITERATOR_HPP
# define MAP_ITERATOR_HPP

# include <iterator>
# include "node.hpp"

namespace ft
{
	template<class Key, class T, class Compare = std::less<Key>>
	class map_iterator
	{
		private:
			typedef ft::node<Key, T>	node;
		public:

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/********************************************************************************************************************************/
		/***********************************************************CONSTRUCTOR***********************************************************/
		/********************************************************************************************************************************/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			map_iterator(): _node(NULL), _isend(false){};
			map_iterator(const map_iterator<const Key, T, Compare> &other): _node(other.getNode()), _isend(other.getEnd()){};
			~map_iterator(){};

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/********************************************************************************************************************************/
		/************************************************************GET VALUE***********************************************************/
		/********************************************************************************************************************************/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
			node	*getNode( void ) const { return _node; }
			bool	isEnd( void ) const { return _isend; }


			node	TreeMinimum(node root)
			{
				node*	hisParent;

				while (!root->leftChild->isNil())
				{
					root = root->left;
				}
				return (root);
			}
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/********************************************************************************************************************************/
		/************************************************************OVERLOAD************************************************************/
		/********************************************************************************************************************************/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// map_iterator &operator=( const map_iterator<const Key, T, Compare> &other)
			// {
			// 	if (&other == this)
			// 		return (*this);
			// 	this->_node = other->_node;
			// 	this->_isend = other->_isend;
			// 	return (*this); 
			// }
			// friend bool &operator==( const map_iterator &lhs, const map_iterator &rhs)
			// {
			// 	if (lhs._isend != rhs._isend)
			// 		return false;
			// 	else if (lsh._isend == true)
			// 		return true;
			// 	return (lsh._node == rhs._node);
			// }
			// friend bool &operator!=( const map_iterator &lhs, const map_iterator &rhs)
			// {
			// 	if (lhs._isend != rhs._isend)
			// 		return false;
			// 	else if (lsh._isend == true)
			// 		return true;
			// 	return (lsh._node != rhs._node);
			// }
			// map_iterator operator++(int)
			// map_iterator operator--(int)
			// map_iterator &operator++()
			// map_iterator &operator--()
		private:
			node	*_node;
			bool 	_isend;
	};
}


#endif
